// @flow-weaver-runtime-start
// ============================================================================
// DO NOT EDIT - This section is auto-generated by Flow Weaver
// ============================================================================

// ============================================================================
// Runtime Types
// ============================================================================

type TStatusType = 'RUNNING' | 'SCHEDULED' | 'SUCCEEDED' | 'FAILED' | 'CANCELLED' | 'PENDING';

type TVariableIdentification = {
  nodeTypeName: string;
  id: string;
  scope?: string;
  side?: 'start' | 'exit';
  portName: string;
  executionIndex: number;
  key?: string;
};

type TStatusChangedEvent = {
  type: 'STATUS_CHANGED';
  nodeTypeName: string;
  id: string;
  scope?: string;
  side?: 'start' | 'exit';
  executionIndex: number;
  status: TStatusType;
  innerFlowInvocation?: boolean;
};

type TVariableSetEvent = {
  type: 'VARIABLE_SET';
  identifier: TVariableIdentification;
  value?: unknown;
  innerFlowInvocation?: boolean;
};

type TErrorLogEvent = {
  type: 'LOG_ERROR';
  nodeTypeName: string;
  id: string;
  scope?: string;
  side?: 'start' | 'exit';
  executionIndex: number;
  error: string;
  innerFlowInvocation?: boolean;
};

type TWorkflowCompletedEvent = {
  type: 'WORKFLOW_COMPLETED';
  executionIndex: number;
  status: 'SUCCEEDED' | 'FAILED' | 'CANCELLED';
  result?: unknown;
  innerFlowInvocation?: boolean;
};

type TEvent = TStatusChangedEvent | TVariableSetEvent | TErrorLogEvent | TWorkflowCompletedEvent;

type TDebugger = {
  sendEvent: (event: TEvent) => void;
  innerFlowInvocation: boolean;
  sessionId?: string;
};

declare const __flowWeaverDebugger__: TDebugger | undefined;

declare const __abortSignal__: AbortSignal | undefined;

interface VariableAddress {
  id: string;
  portName: string;
  executionIndex: number;
  nodeTypeName?: string;
  scope?: string;
  side?: 'start' | 'exit';
}

interface ExecutionInfo {
  id: string;
  index: number;
  parentIndex?: number;
  scopeName?: string;
}

type VariableValue = unknown | (() => unknown) | (() => Promise<unknown>);

// ============================================================================
// Cancellation Error
// ============================================================================

class CancellationError extends Error {
  public readonly executionIndex: number;
  public readonly nodeId?: string;
  public readonly timestamp: number;

  constructor(
    message: string = 'Workflow execution cancelled',
    executionIndex: number = 0,
    nodeId?: string,
    timestamp: number = Date.now()
  ) {
    super(message);
    this.name = 'CancellationError';
    this.executionIndex = executionIndex;
    this.nodeId = nodeId;
    this.timestamp = timestamp;
  }

  static isCancellationError(error: unknown): error is CancellationError {
    return (
      error instanceof CancellationError ||
      (error instanceof Error && error.name === 'CancellationError')
    );
  }
}

// ============================================================================
// Execution Context
// ============================================================================

class GeneratedExecutionContext {
  private variables: Map<string, VariableValue> = new Map();
  private executions: Map<string, ExecutionInfo> = new Map();
  private executionCounter: number = 0;
  private nodeExecutionCounts: Map<string, number> = new Map();
  private isAsync: boolean;
  private flowWeaverDebugger?: TDebugger;
  private pullExecutors: Map<string, () => void | Promise<void>> = new Map();
  private nodeExecutionIndices: Map<string, number> = new Map();
  private abortSignal?: AbortSignal;

  constructor(isAsync: boolean = true, flowWeaverDebugger?: TDebugger, abortSignal?: AbortSignal) {
    this.isAsync = isAsync;
    this.flowWeaverDebugger = flowWeaverDebugger;
    this.abortSignal = abortSignal;
  }

  registerPullExecutor(id: string, executor: () => void | Promise<void>): void {
    this.pullExecutors.set(id, executor);
  }

  addExecution(id: string, parentIndex?: number, scopeName?: string): number {
    // Use per-node execution counter (each node starts at 0)
    const currentCount = this.nodeExecutionCounts.get(id) || 0;
    const index = currentCount;
    this.nodeExecutionCounts.set(id, currentCount + 1);
    this.executionCounter++;
    this.executions.set(this.getExecutionKey(id, index), {
      id,
      index,
      parentIndex,
      scopeName,
    });
    this.nodeExecutionIndices.set(id, index);
    return index;
  }

  setVariable(address: VariableAddress, value: VariableValue): void | Promise<void> {
    const key = this.getVariableKey(address);
    this.variables.set(key, value);
    if (this.flowWeaverDebugger) {
      const actualValue = typeof value === 'function' ? value() : value;
      this.sendVariableSetEvent({
        identifier: {
          nodeTypeName: address.nodeTypeName || 'unknown',
          id: address.id,
          portName: address.portName,
          executionIndex: address.executionIndex,
          key: 'default',
          ...(address.scope && { scope: address.scope }),
          ...(address.side && { side: address.side }),
        },
        value: actualValue,
      });
    }
    return this.isAsync ? Promise.resolve() : undefined;
  }

  getVariable(address: VariableAddress): unknown | Promise<unknown> {
    const executor = this.pullExecutors.get(address.id);
    if (executor) {
      if (!this.hasVariable(address)) {
        const result = executor();
        // Handle async executor (returns Promise)
        if (result instanceof Promise) {
          return result.then(() => {
            const trackedIndex = this.nodeExecutionIndices.get(address.id);
            const finalAddress =
              trackedIndex !== undefined ? { ...address, executionIndex: trackedIndex } : address;
            return this.retrieveVariable(finalAddress);
          });
        }
        // Handle sync executor (returns void)
        const trackedIndex = this.nodeExecutionIndices.get(address.id);
        const finalAddress =
          trackedIndex !== undefined ? { ...address, executionIndex: trackedIndex } : address;
        return this.retrieveVariable(finalAddress);
      }
    }
    return this.retrieveVariable(address);
  }

  private retrieveVariable(address: VariableAddress): unknown | Promise<unknown> {
    const key = this.getVariableKey(address);
    const value = this.variables.get(key);
    if (value === undefined) {
      throw new Error(
        `Variable not found: ${address.id}.${address.portName}[${address.executionIndex}]`
      );
    }
    if (typeof value === 'function') {
      const result = value();
      if (result instanceof Promise) {
        return result;
      }
      return this.isAsync ? Promise.resolve(result) : result;
    }
    return this.isAsync ? Promise.resolve(value) : value;
  }

  hasVariable(address: VariableAddress): boolean {
    const key = this.getVariableKey(address);
    return this.variables.has(key);
  }

  getExecution(id: string, index: number): ExecutionInfo | undefined {
    return this.executions.get(this.getExecutionKey(id, index));
  }

  createScope(
    _parentNodeName: string,
    _parentIndex: number,
    _scopeName: string,
    cleanScope: boolean = false
  ): GeneratedExecutionContext {
    const scopedContext = new GeneratedExecutionContext(
      this.isAsync,
      this.flowWeaverDebugger,
      this.abortSignal
    );
    // For per-port function scopes (cleanScope=true), start with empty variables
    // For node-level scopes (cleanScope=false), inherit parent variables
    scopedContext.variables = cleanScope ? new Map() : new Map(this.variables);
    scopedContext.executions = new Map(this.executions);
    scopedContext.executionCounter = this.executionCounter;
    scopedContext.nodeExecutionCounts = new Map(this.nodeExecutionCounts);
    return scopedContext;
  }

  mergeScope(scopedContext: GeneratedExecutionContext): void {
    scopedContext.executions.forEach((info, key) => {
      this.executions.set(key, info);
    });
    scopedContext.variables.forEach((value, key) => {
      this.variables.set(key, value);
    });
    this.executionCounter = Math.max(this.executionCounter, scopedContext.executionCounter);
    scopedContext.nodeExecutionCounts.forEach((count, id) => {
      const currentCount = this.nodeExecutionCounts.get(id) || 0;
      this.nodeExecutionCounts.set(id, Math.max(currentCount, count));
    });
  }

  private getVariableKey(address: VariableAddress): string {
    return `${address.id}:${address.portName}:${address.executionIndex}`;
  }

  private getExecutionKey(id: string, index: number): string {
    return `${id}:${index}`;
  }

  getExecutionCount(): number {
    return this.executionCounter;
  }

  reset(): void {
    this.variables.clear();
    this.executions.clear();
    this.executionCounter = 0;
    this.nodeExecutionCounts.clear();
  }

  isAborted(): boolean {
    return this.abortSignal?.aborted ?? false;
  }

  checkAborted(nodeId?: string): void {
    if (this.abortSignal?.aborted) {
      throw new CancellationError(
        `Workflow execution cancelled${nodeId ? ` at ${nodeId}` : ''}`,
        this.executionCounter,
        nodeId
      );
    }
  }

  sendStatusChangedEvent(args: {
    nodeTypeName: string;
    id: string;
    scope?: string;
    side?: 'start' | 'exit';
    executionIndex: number;
    status: TStatusType;
  }): void {
    if (this.flowWeaverDebugger) {
      this.flowWeaverDebugger.sendEvent({
        type: 'STATUS_CHANGED',
        ...args,
        innerFlowInvocation: this.flowWeaverDebugger.innerFlowInvocation,
      });
    }
  }

  private sendVariableSetEvent(args: {
    identifier: TVariableIdentification;
    value: unknown;
  }): void {
    if (this.flowWeaverDebugger) {
      this.flowWeaverDebugger.sendEvent({
        type: 'VARIABLE_SET',
        ...args,
        innerFlowInvocation: this.flowWeaverDebugger.innerFlowInvocation,
      });
    }
  }

  sendLogErrorEvent(args: {
    nodeTypeName: string;
    id: string;
    scope?: string;
    side?: 'start' | 'exit';
    executionIndex: number;
    error: string;
  }): void {
    if (this.flowWeaverDebugger) {
      this.flowWeaverDebugger.sendEvent({
        type: 'LOG_ERROR',
        ...args,
        innerFlowInvocation: this.flowWeaverDebugger.innerFlowInvocation,
      });
    }
  }

  sendWorkflowCompletedEvent(args: {
    executionIndex: number;
    status: 'SUCCEEDED' | 'FAILED' | 'CANCELLED';
    result?: unknown;
  }): void {
    if (this.flowWeaverDebugger) {
      this.flowWeaverDebugger.sendEvent({
        type: 'WORKFLOW_COMPLETED',
        ...args,
        innerFlowInvocation: this.flowWeaverDebugger.innerFlowInvocation,
      });
    }
  }
}

// ============================================================================
// Inline Debug Client (auto-created from FLOW_WEAVER_DEBUG env var)
// ============================================================================

/* eslint-disable @typescript-eslint/no-require-imports */
function createFlowWeaverDebugClient(url: string, workflowExportName: string): any {
  let ws: any = null;
  let connected = false;
  const queue: string[] = [];
  const sessionId = Math.random().toString(36).substring(2, 15);

  const connect = () => {
    try {
      // Node.js environment - require 'ws' package
      const WS = require('ws');
      ws = new WS(url);

      ws.on('open', () => {
        connected = true;
        // Send connect message
        ws.send(
          JSON.stringify({
            type: 'connect',
            sessionId,
            workflowExportName,
            clientInfo: {
              platform: process.platform,
              nodeVersion: process.version,
              pid: process.pid,
            },
          })
        );

        // Flush queued events
        while (queue.length > 0) {
          const msg = queue.shift();
          if (ws.readyState === 1) ws.send(msg);
        }
      });

      ws.on('error', () => {
        connected = false;
      });
      ws.on('close', () => {
        connected = false;
      });
    } catch (err: unknown) {
      // Silently fail if 'ws' package not available
      console.warn(
        '[Flow Weaver] Debug client failed to connect:',
        err instanceof Error ? err.message : String(err)
      );
    }
  };

  return {
    sendEvent: (event: unknown) => {
      const message = JSON.stringify({ type: 'event', sessionId, event });
      if (!ws) connect();
      if (connected && ws.readyState === 1) {
        ws.send(message);
      } else {
        queue.push(message);
      }
    },
    innerFlowInvocation: false,
    sessionId,
  };
}
/* eslint-enable @typescript-eslint/no-require-imports */

// @flow-weaver-runtime-end
/**
 * Convert text to uppercase
 *
 * @flowWeaver nodeType
 * @expression
 * @label To Upper Case
 * @input text [order:1] - Text to convert
 * @output result [order:2] - Uppercased text
 */
function toUpperCase(text: string): string {
  return text.toUpperCase();
}

/**
 * Concatenate two strings with a separator
 *
 * @flowWeaver nodeType
 * @expression
 * @label Concatenate
 * @input a [order:1] - First string
 * @input b [order:2] - Second string
 * @output result [order:2] - Combined string
 */
function concatenate(a: string, b: string): string {
  return `${a} ${b}`;
}

/**
 * Get the length of a string
 *
 * @flowWeaver nodeType
 * @expression
 * @label Get Length
 * @input text [order:1] - Text to measure
 * @output length [order:2] - Character count
 */
function getLength(text: string): number {
  return text.length;
}

// ============================================================================
// WORKFLOW
// ============================================================================

/**
 * @flowWeaver workflow
 * @node upper toUpperCase [position: 180 0]
 * @node concat concatenate [position: 360 0]
 * @node len getLength [position: 360 150]
 * @path Start -> upper -> concat -> Exit
 * @path Start -> upper -> len -> Exit
 * @connect Start.text -> upper.text
 * @connect upper.result -> concat.a
 * @connect Start.suffix -> concat.b
 * @connect upper.result -> len.text
 * @connect concat.result -> Exit.output
 * @connect len.length -> Exit.length
 * @param execute [order:0] - Execute
 * @param text [order:1] - Text
 * @param suffix [order:2] - Suffix
 * @returns onSuccess [order:0] - On Success
 * @returns onFailure [order:1] - On Failure
 * @returns output [order:2] - Output
 * @returns length [order:3] - Length
 */
export function textTransform(
  execute: boolean,
  params: { text: string; suffix: string },
  __abortSignal__?: AbortSignal
): { onSuccess: boolean; onFailure: boolean; output: string; length: number } {
  // @flow-weaver-body-start
  // ============================================================================
  // DO NOT EDIT - This section is auto-generated by Flow Weaver
  // Edit the @flowWeaver annotations above to modify workflow behavior
  // ============================================================================

  // Use passed debugger or auto-detect from environment variable
  const __effectiveDebugger__ =
    typeof __flowWeaverDebugger__ !== 'undefined'
      ? __flowWeaverDebugger__
      : typeof process !== 'undefined' && process.env.FLOW_WEAVER_DEBUG
        ? createFlowWeaverDebugClient(process.env.FLOW_WEAVER_DEBUG, 'textTransform')
        : undefined;

  // Recursion depth protection
  const __rd__ = (params as { __rd__?: number }).__rd__ ?? 0;
  if (__rd__ >= 1000) {
    throw new Error('Max recursion depth exceeded (1000) in workflow "textTransform"');
  }

  const ctx = new GeneratedExecutionContext(false, __effectiveDebugger__, __abortSignal__);

  const startIdx = ctx.addExecution('Start');
  ctx.setVariable(
    { id: 'Start', portName: 'execute', executionIndex: startIdx, nodeTypeName: 'Start' },
    execute
  );
  ctx.setVariable(
    { id: 'Start', portName: 'text', executionIndex: startIdx, nodeTypeName: 'Start' },
    params.text
  );
  ctx.setVariable(
    { id: 'Start', portName: 'suffix', executionIndex: startIdx, nodeTypeName: 'Start' },
    params.suffix
  );
  ctx.sendStatusChangedEvent({
    nodeTypeName: 'Start',
    id: 'Start',
    executionIndex: startIdx,
    status: 'SUCCEEDED',
  });

  ctx.checkAborted('upper');
  const upperIdx = ctx.addExecution('upper');
  ctx.sendStatusChangedEvent({
    nodeTypeName: 'toUpperCase',
    id: 'upper',
    executionIndex: upperIdx,
    status: 'RUNNING',
  });
  try {
    ctx.setVariable(
      { id: 'upper', portName: 'execute', executionIndex: upperIdx, nodeTypeName: 'toUpperCase' },
      true
    );
    const upper_text = ctx.getVariable({
      id: 'Start',
      portName: 'text',
      executionIndex: startIdx,
    }) as string;
    ctx.setVariable(
      { id: 'upper', portName: 'text', executionIndex: upperIdx, nodeTypeName: 'toUpperCase' },
      upper_text
    );
    const upperResult = toUpperCase(upper_text);
    ctx.setVariable(
      { id: 'upper', portName: 'result', executionIndex: upperIdx, nodeTypeName: 'toUpperCase' },
      upperResult
    );
    ctx.setVariable(
      { id: 'upper', portName: 'onSuccess', executionIndex: upperIdx, nodeTypeName: 'toUpperCase' },
      true
    );
    ctx.setVariable(
      { id: 'upper', portName: 'onFailure', executionIndex: upperIdx, nodeTypeName: 'toUpperCase' },
      false
    );
    ctx.sendStatusChangedEvent({
      nodeTypeName: 'toUpperCase',
      id: 'upper',
      executionIndex: upperIdx,
      status: 'SUCCEEDED',
    });
  } catch (error: unknown) {
    const isCancellation = CancellationError.isCancellationError(error);
    ctx.sendStatusChangedEvent({
      nodeTypeName: 'toUpperCase',
      id: 'upper',
      executionIndex: upperIdx,
      status: isCancellation ? 'CANCELLED' : 'FAILED',
    });
    if (!isCancellation) {
      ctx.sendLogErrorEvent({
        nodeTypeName: 'toUpperCase',
        id: 'upper',
        executionIndex: upperIdx,
        error: error instanceof Error ? error.message : String(error),
      });
      ctx.setVariable(
        {
          id: 'upper',
          portName: 'onSuccess',
          executionIndex: upperIdx,
          nodeTypeName: 'toUpperCase',
        },
        false
      );
      ctx.setVariable(
        {
          id: 'upper',
          portName: 'onFailure',
          executionIndex: upperIdx,
          nodeTypeName: 'toUpperCase',
        },
        true
      );
    }
    throw error;
  }
  ctx.checkAborted('concat');
  const concatIdx = ctx.addExecution('concat');
  ctx.sendStatusChangedEvent({
    nodeTypeName: 'concatenate',
    id: 'concat',
    executionIndex: concatIdx,
    status: 'RUNNING',
  });
  try {
    ctx.setVariable(
      { id: 'concat', portName: 'execute', executionIndex: concatIdx, nodeTypeName: 'concatenate' },
      true
    );
    const concat_a = ctx.getVariable({
      id: 'upper',
      portName: 'result',
      executionIndex: upperIdx!,
    }) as string;
    ctx.setVariable(
      { id: 'concat', portName: 'a', executionIndex: concatIdx, nodeTypeName: 'concatenate' },
      concat_a
    );
    const concat_b = ctx.getVariable({
      id: 'Start',
      portName: 'suffix',
      executionIndex: startIdx,
    }) as string;
    ctx.setVariable(
      { id: 'concat', portName: 'b', executionIndex: concatIdx, nodeTypeName: 'concatenate' },
      concat_b
    );
    const concatResult = concatenate(concat_a, concat_b);
    ctx.setVariable(
      { id: 'concat', portName: 'result', executionIndex: concatIdx, nodeTypeName: 'concatenate' },
      concatResult
    );
    ctx.setVariable(
      {
        id: 'concat',
        portName: 'onSuccess',
        executionIndex: concatIdx,
        nodeTypeName: 'concatenate',
      },
      true
    );
    ctx.setVariable(
      {
        id: 'concat',
        portName: 'onFailure',
        executionIndex: concatIdx,
        nodeTypeName: 'concatenate',
      },
      false
    );
    ctx.sendStatusChangedEvent({
      nodeTypeName: 'concatenate',
      id: 'concat',
      executionIndex: concatIdx,
      status: 'SUCCEEDED',
    });
  } catch (error: unknown) {
    const isCancellation = CancellationError.isCancellationError(error);
    ctx.sendStatusChangedEvent({
      nodeTypeName: 'concatenate',
      id: 'concat',
      executionIndex: concatIdx,
      status: isCancellation ? 'CANCELLED' : 'FAILED',
    });
    if (!isCancellation) {
      ctx.sendLogErrorEvent({
        nodeTypeName: 'concatenate',
        id: 'concat',
        executionIndex: concatIdx,
        error: error instanceof Error ? error.message : String(error),
      });
      ctx.setVariable(
        {
          id: 'concat',
          portName: 'onSuccess',
          executionIndex: concatIdx,
          nodeTypeName: 'concatenate',
        },
        false
      );
      ctx.setVariable(
        {
          id: 'concat',
          portName: 'onFailure',
          executionIndex: concatIdx,
          nodeTypeName: 'concatenate',
        },
        true
      );
    }
    throw error;
  }
  ctx.checkAborted('len');
  const lenIdx = ctx.addExecution('len');
  ctx.sendStatusChangedEvent({
    nodeTypeName: 'getLength',
    id: 'len',
    executionIndex: lenIdx,
    status: 'RUNNING',
  });
  try {
    ctx.setVariable(
      { id: 'len', portName: 'execute', executionIndex: lenIdx, nodeTypeName: 'getLength' },
      true
    );
    const len_text = ctx.getVariable({
      id: 'upper',
      portName: 'result',
      executionIndex: upperIdx!,
    }) as string;
    ctx.setVariable(
      { id: 'len', portName: 'text', executionIndex: lenIdx, nodeTypeName: 'getLength' },
      len_text
    );
    const lenResult = getLength(len_text);
    ctx.setVariable(
      { id: 'len', portName: 'length', executionIndex: lenIdx, nodeTypeName: 'getLength' },
      lenResult
    );
    ctx.setVariable(
      { id: 'len', portName: 'onSuccess', executionIndex: lenIdx, nodeTypeName: 'getLength' },
      true
    );
    ctx.setVariable(
      { id: 'len', portName: 'onFailure', executionIndex: lenIdx, nodeTypeName: 'getLength' },
      false
    );
    ctx.sendStatusChangedEvent({
      nodeTypeName: 'getLength',
      id: 'len',
      executionIndex: lenIdx,
      status: 'SUCCEEDED',
    });
  } catch (error: unknown) {
    const isCancellation = CancellationError.isCancellationError(error);
    ctx.sendStatusChangedEvent({
      nodeTypeName: 'getLength',
      id: 'len',
      executionIndex: lenIdx,
      status: isCancellation ? 'CANCELLED' : 'FAILED',
    });
    if (!isCancellation) {
      ctx.sendLogErrorEvent({
        nodeTypeName: 'getLength',
        id: 'len',
        executionIndex: lenIdx,
        error: error instanceof Error ? error.message : String(error),
      });
      ctx.setVariable(
        { id: 'len', portName: 'onSuccess', executionIndex: lenIdx, nodeTypeName: 'getLength' },
        false
      );
      ctx.setVariable(
        { id: 'len', portName: 'onFailure', executionIndex: lenIdx, nodeTypeName: 'getLength' },
        true
      );
    }
    throw error;
  }
  const exitIdx = ctx.addExecution('Exit');
  const exit_output = ctx.getVariable({
    id: 'concat',
    portName: 'result',
    executionIndex: concatIdx,
  });
  ctx.setVariable(
    { id: 'Exit', portName: 'output', executionIndex: exitIdx, nodeTypeName: 'Exit' },
    exit_output
  );
  const exit_length = ctx.getVariable({ id: 'len', portName: 'length', executionIndex: lenIdx });
  ctx.setVariable(
    { id: 'Exit', portName: 'length', executionIndex: exitIdx, nodeTypeName: 'Exit' },
    exit_length
  );

  ctx.setVariable(
    { id: 'Exit', portName: 'onSuccess', executionIndex: exitIdx, nodeTypeName: 'Exit' },
    true
  );
  ctx.setVariable(
    { id: 'Exit', portName: 'onFailure', executionIndex: exitIdx, nodeTypeName: 'Exit' },
    false
  );
  const finalResult = {
    onSuccess: true,
    onFailure: false,
    output: exit_output as string,
    length: exit_length as number,
  };

  ctx.sendStatusChangedEvent({
    nodeTypeName: 'Exit',
    id: 'Exit',
    executionIndex: exitIdx,
    status: 'SUCCEEDED',
  });
  ctx.sendWorkflowCompletedEvent({
    executionIndex: 0,
    status: 'SUCCEEDED',
    result: finalResult,
  });

  return finalResult;
  // @flow-weaver-body-end
}
