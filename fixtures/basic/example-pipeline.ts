
// @flow-weaver-runtime-start
// ============================================================================
// DO NOT EDIT - This section is auto-generated by Flow Weaver
// ============================================================================

import { GeneratedExecutionContext, CancellationError } from '@synergenius/flow-weaver/runtime';
import type { TDebugger } from '@synergenius/flow-weaver/runtime';
// @flow-weaver-runtime-end
/**
 * @path example — linear chain sugar for sequential workflows.
 *
 * @path auto-wires a specified chain of nodes:
 *   Start → validator → transformer → outputter → Exit
 * Control flow (onSuccess→execute) and matching data ports are connected automatically.
 *
 * Run: flow-weaver run fixtures/basic/example-pipeline.ts --params '{"data":"hello world"}'
 */

/**
 * @flowWeaver nodeType
 * @input data [order:1]
 * @input execute [order:0] - Execute
 * @output result [order:2]
 * @output onSuccess [order:0] - On Success
 * @output onFailure [order:1] - On Failure
 */
function validateInput(execute: boolean, data: string): {
  onSuccess: boolean;
  onFailure: boolean;
  result: string;
} {
  if (!execute) return { onSuccess: false, onFailure: false, result: '' };
  if (!data || data.trim().length === 0) {
    return { onSuccess: false, onFailure: true, result: '' };
  }
  return { onSuccess: true, onFailure: false, result: data.trim() };
}

/**
 * @flowWeaver nodeType
 * @input result [order:1]
 * @input execute [order:0] - Execute
 * @output result [order:2]
 * @output onSuccess [order:0] - On Success
 * @output onFailure [order:1] - On Failure
 */
function transformData(execute: boolean, result: string): {
  onSuccess: boolean;
  onFailure: boolean;
  result: string;
} {
  if (!execute) return { onSuccess: false, onFailure: false, result: '' };
  return { onSuccess: true, onFailure: false, result: result.toUpperCase() };
}

/**
 * @flowWeaver nodeType
 * @input result [order:1]
 * @input execute [order:0] - Execute
 * @output result [order:2]
 * @output onSuccess [order:0] - On Success
 * @output onFailure [order:1] - On Failure
 */
function formatOutput(execute: boolean, result: string): {
  onSuccess: boolean;
  onFailure: boolean;
  result: string;
} {
  if (!execute) return { onSuccess: false, onFailure: false, result: '' };
  return { onSuccess: true, onFailure: false, result: `[OUTPUT] ${result}` };
}

/**
 * @flowWeaver workflow
 * @node validator validateInput [position: 270 0]
 * @node transformer transformData [position: 540 0]
 * @node outputter formatOutput [position: 810 0]
 * @path Start -> validator -> transformer -> outputter -> Exit
 * @position Start 0 0
 * @position Exit 1080 0
 * @param execute [order:0] - Execute
 * @param data [order:1] - Data
 * @returns onSuccess [order:0] - On Success
 * @returns onFailure [order:1] - On Failure
 * @returns result [order:2] - Result
 */
export function dataPipeline(
  execute: boolean,
  params: { data: string }, __abortSignal__?: AbortSignal
): { onSuccess: boolean; onFailure: boolean; result: string } {
  // @flow-weaver-body-start
  // ============================================================================
  // DO NOT EDIT - This section is auto-generated by Flow Weaver
  // Edit the @flowWeaver annotations above to modify workflow behavior
  // ============================================================================

    // Use passed debugger or auto-detect from environment variable
    const __effectiveDebugger__ = (
      typeof __flowWeaverDebugger__ !== 'undefined' ? __flowWeaverDebugger__ :
      typeof process !== 'undefined' && process.env.FLOW_WEAVER_DEBUG
        ? createFlowWeaverDebugClient(process.env.FLOW_WEAVER_DEBUG, 'dataPipeline')
        : undefined
    );

    // Recursion depth protection
    const __rd__ = (params as { __rd__?: number }).__rd__ ?? 0;
    if (__rd__ >= 1000) {
      throw new Error('Max recursion depth exceeded (1000) in workflow "dataPipeline"');
    }

    const ctx = new GeneratedExecutionContext(false, __effectiveDebugger__, __abortSignal__);

    const startIdx = ctx.addExecution('Start');
    ctx.setVariable({ id: 'Start', portName: 'execute', executionIndex: startIdx, nodeTypeName: 'Start' }, execute);
    ctx.setVariable({ id: 'Start', portName: 'data', executionIndex: startIdx, nodeTypeName: 'Start' }, params.data);
    ctx.sendStatusChangedEvent({
      nodeTypeName: 'Start',
      id: 'Start',
      executionIndex: startIdx,
      status: 'SUCCEEDED',
    });

    let validatorIdx: number | undefined;
    let transformerIdx: number | undefined;
    let outputterIdx: number | undefined;

    let validator_success = false;
    let transformer_success = false;

    ctx.checkAborted('validator');
    validatorIdx = ctx.addExecution('validator');
    ctx.sendStatusChangedEvent({
      nodeTypeName: 'validateInput',
      id: 'validator',
      executionIndex: validatorIdx,
      status: 'RUNNING',
    });

    validator_success = false;

    try {
      const validator_execute = ctx.getVariable({ id: 'Start', portName: 'execute', executionIndex: startIdx }) as boolean;
      ctx.setVariable({ id: 'validator', portName: 'execute', executionIndex: validatorIdx, nodeTypeName: 'validateInput' }, validator_execute);
      const validator_data = ctx.getVariable({ id: 'Start', portName: 'data', executionIndex: startIdx }) as string;
      ctx.setVariable({ id: 'validator', portName: 'data', executionIndex: validatorIdx, nodeTypeName: 'validateInput' }, validator_data);
      const validatorResult = validateInput(validator_execute, validator_data);
      ctx.setVariable({ id: 'validator', portName: 'result', executionIndex: validatorIdx, nodeTypeName: 'validateInput' }, validatorResult.result);
      ctx.setVariable({ id: 'validator', portName: 'onSuccess', executionIndex: validatorIdx, nodeTypeName: 'validateInput' }, validatorResult.onSuccess);
      ctx.setVariable({ id: 'validator', portName: 'onFailure', executionIndex: validatorIdx, nodeTypeName: 'validateInput' }, validatorResult.onFailure);
      ctx.sendStatusChangedEvent({
        nodeTypeName: 'validateInput',
        id: 'validator',
        executionIndex: validatorIdx,
        status: 'SUCCEEDED',
      });
      validator_success = validatorResult.onSuccess;
    } catch (error: unknown) {
      const isCancellation = CancellationError.isCancellationError(error);
      ctx.sendStatusChangedEvent({
        nodeTypeName: 'validateInput',
        id: 'validator',
        executionIndex: validatorIdx,
        status: isCancellation ? 'CANCELLED' : 'FAILED',
      });
      if (!isCancellation) {
        ctx.sendLogErrorEvent({
          nodeTypeName: 'validateInput',
          id: 'validator',
          executionIndex: validatorIdx,
          error: error instanceof Error ? error.message : String(error),
        });
        ctx.setVariable({ id: 'validator', portName: 'onSuccess', executionIndex: validatorIdx, nodeTypeName: 'validateInput' }, false);
        ctx.setVariable({ id: 'validator', portName: 'onFailure', executionIndex: validatorIdx, nodeTypeName: 'validateInput' }, true);
        validator_success = false;
      }
      throw error;
    }

    if (validator_success) {
      ctx.checkAborted('transformer');
      transformerIdx = ctx.addExecution('transformer');
      ctx.sendStatusChangedEvent({
        nodeTypeName: 'transformData',
        id: 'transformer',
        executionIndex: transformerIdx,
        status: 'RUNNING',
      });

      transformer_success = false;

      try {
        const transformer_execute = ctx.getVariable({ id: 'validator', portName: 'onSuccess', executionIndex: validatorIdx! }) as boolean;
        ctx.setVariable({ id: 'transformer', portName: 'execute', executionIndex: transformerIdx, nodeTypeName: 'transformData' }, transformer_execute);
        const transformer_result = ctx.getVariable({ id: 'validator', portName: 'result', executionIndex: validatorIdx! }) as string;
        ctx.setVariable({ id: 'transformer', portName: 'result', executionIndex: transformerIdx, nodeTypeName: 'transformData' }, transformer_result);
        const transformerResult = transformData(transformer_execute, transformer_result);
        ctx.setVariable({ id: 'transformer', portName: 'result', executionIndex: transformerIdx, nodeTypeName: 'transformData' }, transformerResult.result);
        ctx.setVariable({ id: 'transformer', portName: 'onSuccess', executionIndex: transformerIdx, nodeTypeName: 'transformData' }, transformerResult.onSuccess);
        ctx.setVariable({ id: 'transformer', portName: 'onFailure', executionIndex: transformerIdx, nodeTypeName: 'transformData' }, transformerResult.onFailure);
        ctx.sendStatusChangedEvent({
          nodeTypeName: 'transformData',
          id: 'transformer',
          executionIndex: transformerIdx,
          status: 'SUCCEEDED',
        });
        transformer_success = transformerResult.onSuccess;
      } catch (error: unknown) {
        const isCancellation = CancellationError.isCancellationError(error);
        ctx.sendStatusChangedEvent({
          nodeTypeName: 'transformData',
          id: 'transformer',
          executionIndex: transformerIdx,
          status: isCancellation ? 'CANCELLED' : 'FAILED',
        });
        if (!isCancellation) {
          ctx.sendLogErrorEvent({
            nodeTypeName: 'transformData',
            id: 'transformer',
            executionIndex: transformerIdx,
            error: error instanceof Error ? error.message : String(error),
          });
          ctx.setVariable({ id: 'transformer', portName: 'onSuccess', executionIndex: transformerIdx, nodeTypeName: 'transformData' }, false);
          ctx.setVariable({ id: 'transformer', portName: 'onFailure', executionIndex: transformerIdx, nodeTypeName: 'transformData' }, true);
          transformer_success = false;
        }
        throw error;
      }

    } else {
      const transformerIdx = ctx.addExecution('transformer');
      ctx.sendStatusChangedEvent({
        nodeTypeName: 'transformData',
        id: 'transformer',
        executionIndex: transformerIdx,
        status: 'CANCELLED',
      });
      const outputterIdx = ctx.addExecution('outputter');
      ctx.sendStatusChangedEvent({
        nodeTypeName: 'formatOutput',
        id: 'outputter',
        executionIndex: outputterIdx,
        status: 'CANCELLED',
      });
    }
    if (validator_success && transformer_success) {
      ctx.checkAborted('outputter');
      outputterIdx = ctx.addExecution('outputter');
      ctx.sendStatusChangedEvent({
        nodeTypeName: 'formatOutput',
        id: 'outputter',
        executionIndex: outputterIdx,
        status: 'RUNNING',
      });

      try {
        const outputter_execute = ctx.getVariable({ id: 'transformer', portName: 'onSuccess', executionIndex: transformerIdx! }) as boolean;
        ctx.setVariable({ id: 'outputter', portName: 'execute', executionIndex: outputterIdx, nodeTypeName: 'formatOutput' }, outputter_execute);
        const outputter_result = ctx.getVariable({ id: 'transformer', portName: 'result', executionIndex: transformerIdx! }) as string;
        ctx.setVariable({ id: 'outputter', portName: 'result', executionIndex: outputterIdx, nodeTypeName: 'formatOutput' }, outputter_result);
        const outputterResult = formatOutput(outputter_execute, outputter_result);
        ctx.setVariable({ id: 'outputter', portName: 'result', executionIndex: outputterIdx, nodeTypeName: 'formatOutput' }, outputterResult.result);
        ctx.setVariable({ id: 'outputter', portName: 'onSuccess', executionIndex: outputterIdx, nodeTypeName: 'formatOutput' }, outputterResult.onSuccess);
        ctx.setVariable({ id: 'outputter', portName: 'onFailure', executionIndex: outputterIdx, nodeTypeName: 'formatOutput' }, outputterResult.onFailure);
        ctx.sendStatusChangedEvent({
          nodeTypeName: 'formatOutput',
          id: 'outputter',
          executionIndex: outputterIdx,
          status: 'SUCCEEDED',
        });
      } catch (error: unknown) {
        const isCancellation = CancellationError.isCancellationError(error);
        ctx.sendStatusChangedEvent({
          nodeTypeName: 'formatOutput',
          id: 'outputter',
          executionIndex: outputterIdx,
          status: isCancellation ? 'CANCELLED' : 'FAILED',
        });
        if (!isCancellation) {
          ctx.sendLogErrorEvent({
            nodeTypeName: 'formatOutput',
            id: 'outputter',
            executionIndex: outputterIdx,
            error: error instanceof Error ? error.message : String(error),
          });
          ctx.setVariable({ id: 'outputter', portName: 'onSuccess', executionIndex: outputterIdx, nodeTypeName: 'formatOutput' }, false);
          ctx.setVariable({ id: 'outputter', portName: 'onFailure', executionIndex: outputterIdx, nodeTypeName: 'formatOutput' }, true);
        }
        throw error;
      }

    } else {
      const outputterIdx = ctx.addExecution('outputter');
      ctx.sendStatusChangedEvent({
        nodeTypeName: 'formatOutput',
        id: 'outputter',
        executionIndex: outputterIdx,
        status: 'CANCELLED',
      });
    }
    const exitIdx = ctx.addExecution('Exit');
    const exit_onSuccess = outputterIdx !== undefined ? ctx.getVariable({ id: 'outputter', portName: 'onSuccess', executionIndex: outputterIdx }) : false;
    ctx.setVariable({ id: 'Exit', portName: 'onSuccess', executionIndex: exitIdx, nodeTypeName: 'Exit' }, exit_onSuccess);
    // Exit port 'result' has no valid connection - using undefined

    ctx.setVariable({ id: 'Exit', portName: 'onFailure', executionIndex: exitIdx, nodeTypeName: 'Exit' }, false);
    const finalResult = { onFailure: false, onSuccess: exit_onSuccess as boolean, result: undefined as unknown as string };

    ctx.sendStatusChangedEvent({
      nodeTypeName: 'Exit',
      id: 'Exit',
      executionIndex: exitIdx,
      status: 'SUCCEEDED',
    });
    ctx.sendWorkflowCompletedEvent({
      executionIndex: exitIdx,
      status: 'SUCCEEDED',
      result: finalResult,
    });

    return finalResult;
  // @flow-weaver-body-end
}
