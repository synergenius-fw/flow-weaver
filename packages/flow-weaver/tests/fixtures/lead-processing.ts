
// @flow-weaver-runtime-start
// ============================================================================
// DO NOT EDIT - This section is auto-generated by Flow Weaver
// ============================================================================

// ============================================================================
// Runtime Types
// ============================================================================

type TStatusType =
  | "RUNNING"
  | "SCHEDULED"
  | "SUCCEEDED"
  | "FAILED"
  | "CANCELLED"
  | "PENDING";

type TVariableIdentification = {
  nodeTypeName: string;
  id: string;
  scope?: string;
  side?: "start" | "exit";
  portName: string;
  executionIndex: number;
  key?: string;
};

type TStatusChangedEvent = {
  type: "STATUS_CHANGED";
  nodeTypeName: string;
  id: string;
  scope?: string;
  side?: "start" | "exit";
  executionIndex: number;
  status: TStatusType;
  innerFlowInvocation?: boolean;
};

type TVariableSetEvent = {
  type: "VARIABLE_SET";
  identifier: TVariableIdentification;
  value?: unknown;
  innerFlowInvocation?: boolean;
};

type TErrorLogEvent = {
  type: "LOG_ERROR";
  nodeTypeName: string;
  id: string;
  scope?: string;
  side?: "start" | "exit";
  executionIndex: number;
  error: string;
  innerFlowInvocation?: boolean;
};

type TWorkflowCompletedEvent = {
  type: "WORKFLOW_COMPLETED";
  executionIndex: number;
  status: "SUCCEEDED" | "FAILED" | "CANCELLED";
  result?: unknown;
  innerFlowInvocation?: boolean;
};

type TEvent =
  | TStatusChangedEvent
  | TVariableSetEvent
  | TErrorLogEvent
  | TWorkflowCompletedEvent;

type TDebugger = {
  sendEvent: (event: TEvent) => void;
  innerFlowInvocation: boolean;
  sessionId?: string;
};

declare const __flowWeaverDebugger__: TDebugger | undefined;

declare const __abortSignal__: AbortSignal | undefined;

interface VariableAddress {
  id: string;
  portName: string;
  executionIndex: number;
  nodeTypeName?: string;
  scope?: string;
  side?: 'start' | 'exit';
}

interface ExecutionInfo {
  id: string;
  index: number;
  parentIndex?: number;
  scopeName?: string;
}

type VariableValue = unknown | (() => unknown) | (() => Promise<unknown>);

// ============================================================================
// Cancellation Error
// ============================================================================

class CancellationError extends Error {
  public readonly executionIndex: number;
  public readonly nodeId?: string;
  public readonly timestamp: number;

  constructor(
    message: string = 'Workflow execution cancelled',
    executionIndex: number = 0,
    nodeId?: string,
    timestamp: number = Date.now()
  ) {
    super(message);
    this.name = 'CancellationError';
    this.executionIndex = executionIndex;
    this.nodeId = nodeId;
    this.timestamp = timestamp;
  }

  static isCancellationError(error: unknown): error is CancellationError {
    return (
      error instanceof CancellationError ||
      (error instanceof Error && error.name === 'CancellationError')
    );
  }
}

// ============================================================================
// Execution Context
// ============================================================================

class GeneratedExecutionContext {
  private variables: Map<string, VariableValue> = new Map();
  private executions: Map<string, ExecutionInfo> = new Map();
  private executionCounter: number = 0;
  private nodeExecutionCounts: Map<string, number> = new Map();
  private isAsync: boolean;
  private flowWeaverDebugger?: TDebugger;
  private pullExecutors: Map<string, () => void | Promise<void>> = new Map();
  private nodeExecutionIndices: Map<string, number> = new Map();
  private abortSignal?: AbortSignal;

  constructor(isAsync: boolean = true, flowWeaverDebugger?: TDebugger, abortSignal?: AbortSignal) {
    this.isAsync = isAsync;
    this.flowWeaverDebugger = flowWeaverDebugger;
    this.abortSignal = abortSignal;
  }

  registerPullExecutor(id: string, executor: () => void | Promise<void>): void {
    this.pullExecutors.set(id, executor);
  }

  addExecution(id: string, parentIndex?: number, scopeName?: string): number {
    // Use per-node execution counter (each node starts at 0)
    const currentCount = this.nodeExecutionCounts.get(id) || 0;
    const index = currentCount;
    this.nodeExecutionCounts.set(id, currentCount + 1);
    this.executionCounter++;
    this.executions.set(this.getExecutionKey(id, index), {
      id,
      index,
      parentIndex,
      scopeName,
    });
    this.nodeExecutionIndices.set(id, index);
    return index;
  }

  setVariable(address: VariableAddress, value: VariableValue): void | Promise<void> {
    const key = this.getVariableKey(address);
    this.variables.set(key, value);
    if (this.flowWeaverDebugger) {
      const actualValue = typeof value === "function" ? value() : value;
      this.sendVariableSetEvent({
        identifier: {
          nodeTypeName: address.nodeTypeName || "unknown",
          id: address.id,
          portName: address.portName,
          executionIndex: address.executionIndex,
          key: "default",
          ...(address.scope && { scope: address.scope }),
          ...(address.side && { side: address.side }),
        },
        value: actualValue,
      });
    }
    return this.isAsync ? Promise.resolve() : undefined;
  }

  getVariable(address: VariableAddress): unknown | Promise<unknown> {
    const executor = this.pullExecutors.get(address.id);
    if (executor) {
      if (!this.hasVariable(address)) {
        const result = executor();
        // Handle async executor (returns Promise)
        if (result instanceof Promise) {
          return result.then(() => {
            const trackedIndex = this.nodeExecutionIndices.get(address.id);
            const finalAddress = trackedIndex !== undefined
              ? { ...address, executionIndex: trackedIndex }
              : address;
            return this.retrieveVariable(finalAddress);
          });
        }
        // Handle sync executor (returns void)
        const trackedIndex = this.nodeExecutionIndices.get(address.id);
        const finalAddress = trackedIndex !== undefined
          ? { ...address, executionIndex: trackedIndex }
          : address;
        return this.retrieveVariable(finalAddress);
      }
    }
    return this.retrieveVariable(address);
  }

  private retrieveVariable(address: VariableAddress): unknown | Promise<unknown> {
    const key = this.getVariableKey(address);
    const value = this.variables.get(key);
    if (value === undefined) {
      throw new Error(`Variable not found: ${address.id}.${address.portName}[${address.executionIndex}]`);
    }
    if (typeof value === "function") {
      const result = value();
      if (result instanceof Promise) {
        return result;
      }
      return this.isAsync ? Promise.resolve(result) : result;
    }
    return this.isAsync ? Promise.resolve(value) : value;
  }

  hasVariable(address: VariableAddress): boolean {
    const key = this.getVariableKey(address);
    return this.variables.has(key);
  }

  getExecution(id: string, index: number): ExecutionInfo | undefined {
    return this.executions.get(this.getExecutionKey(id, index));
  }

  createScope(_parentNodeName: string, _parentIndex: number, _scopeName: string, cleanScope: boolean = false): GeneratedExecutionContext {
    const scopedContext = new GeneratedExecutionContext(this.isAsync, this.flowWeaverDebugger, this.abortSignal);
    // For per-port function scopes (cleanScope=true), start with empty variables
    // For node-level scopes (cleanScope=false), inherit parent variables
    scopedContext.variables = cleanScope ? new Map() : new Map(this.variables);
    scopedContext.executions = new Map(this.executions);
    scopedContext.executionCounter = this.executionCounter;
    scopedContext.nodeExecutionCounts = new Map(this.nodeExecutionCounts);
    return scopedContext;
  }

  mergeScope(scopedContext: GeneratedExecutionContext): void {
    scopedContext.executions.forEach((info, key) => {
      this.executions.set(key, info);
    });
    scopedContext.variables.forEach((value, key) => {
      this.variables.set(key, value);
    });
    this.executionCounter = Math.max(this.executionCounter, scopedContext.executionCounter);
    scopedContext.nodeExecutionCounts.forEach((count, id) => {
      const currentCount = this.nodeExecutionCounts.get(id) || 0;
      this.nodeExecutionCounts.set(id, Math.max(currentCount, count));
    });
  }

  private getVariableKey(address: VariableAddress): string {
    return `${address.id}:${address.portName}:${address.executionIndex}`;
  }

  private getExecutionKey(id: string, index: number): string {
    return `${id}:${index}`;
  }

  getExecutionCount(): number {
    return this.executionCounter;
  }

  reset(): void {
    this.variables.clear();
    this.executions.clear();
    this.executionCounter = 0;
    this.nodeExecutionCounts.clear();
  }

  isAborted(): boolean {
    return this.abortSignal?.aborted ?? false;
  }

  checkAborted(nodeId?: string): void {
    if (this.abortSignal?.aborted) {
      throw new CancellationError(
        `Workflow execution cancelled${nodeId ? ` at ${nodeId}` : ''}`,
        this.executionCounter,
        nodeId
      );
    }
  }

  sendStatusChangedEvent(args: {
    nodeTypeName: string;
    id: string;
    scope?: string;
    side?: "start" | "exit";
    executionIndex: number;
    status: TStatusType;
  }): void {
    if (this.flowWeaverDebugger) {
      this.flowWeaverDebugger.sendEvent({
        type: "STATUS_CHANGED",
        ...args,
        innerFlowInvocation: this.flowWeaverDebugger.innerFlowInvocation,
      });
    }
  }

  private sendVariableSetEvent(args: {
    identifier: TVariableIdentification;
    value: unknown;
  }): void {
    if (this.flowWeaverDebugger) {
      this.flowWeaverDebugger.sendEvent({
        type: "VARIABLE_SET",
        ...args,
        innerFlowInvocation: this.flowWeaverDebugger.innerFlowInvocation,
      });
    }
  }

  sendLogErrorEvent(args: {
    nodeTypeName: string;
    id: string;
    scope?: string;
    side?: "start" | "exit";
    executionIndex: number;
    error: string;
  }): void {
    if (this.flowWeaverDebugger) {
      this.flowWeaverDebugger.sendEvent({
        type: "LOG_ERROR",
        ...args,
        innerFlowInvocation: this.flowWeaverDebugger.innerFlowInvocation,
      });
    }
  }

  sendWorkflowCompletedEvent(args: {
    executionIndex: number;
    status: "SUCCEEDED" | "FAILED" | "CANCELLED";
    result?: unknown;
  }): void {
    if (this.flowWeaverDebugger) {
      this.flowWeaverDebugger.sendEvent({
        type: "WORKFLOW_COMPLETED",
        ...args,
        innerFlowInvocation: this.flowWeaverDebugger.innerFlowInvocation,
      });
    }
  }
}


// ============================================================================
// Inline Debug Client (auto-created from FLOW_WEAVER_DEBUG env var)
// ============================================================================

interface DebugClient {
  sendEvent: (event: unknown) => void;
  innerFlowInvocation: boolean;
  sessionId: string;
}

interface WebSocketLike {
  readyState: number;
  send: (data: string) => void;
  on: (event: string, handler: () => void) => void;
}

function createFlowWeaverDebugClient(url: string, workflowExportName: string): DebugClient {
  let ws: WebSocketLike | null = null;
  let connected = false;
  const queue: string[] = [];
  const sessionId = Math.random().toString(36).substring(2, 15);

  const connect = () => {
    try {
      // Node.js environment - require 'ws' package
      // eslint-disable-next-line @typescript-eslint/no-require-imports
      const WS = require('ws') as new (url: string) => WebSocketLike;
      ws = new WS(url);

      ws.on('open', () => {
        connected = true;
        // Send connect message
        ws.send(JSON.stringify({
          type: 'connect',
          sessionId,
          workflowExportName,
          clientInfo: {
            platform: process.platform,
            nodeVersion: process.version,
            pid: process.pid
          }
        }));

        // Flush queued events
        while (queue.length > 0) {
          const msg = queue.shift();
          if (ws.readyState === 1) ws.send(msg);
        }
      });

      ws.on('error', () => { connected = false; });
      ws.on('close', () => { connected = false; });
    } catch (err: unknown) {
      // Silently fail if 'ws' package not available
      console.warn('[Flow Weaver] Debug client failed to connect:', err instanceof Error ? err.message : String(err));
    }
  };

  return {
    sendEvent: (event: unknown) => {
      const message = JSON.stringify({ type: 'event', sessionId, event });
      if (!ws) connect();
      if (connected && ws.readyState === 1) {
        ws.send(message);
      } else {
        queue.push(message);
      }
    },
    innerFlowInvocation: false,
    sessionId
  };
}

// @flow-weaver-runtime-end
/**
 * Lead Processing Pipeline
 *
 * A realistic workflow that demonstrates what would be complex in n8n:
 * - Email validation with regex
 * - Data transformation
 * - Scoring algorithm
 * - Conditional categorization
 * - Error handling
 *
 * In n8n, this would require multiple Code nodes with sandboxed JS,
 * confusing expressions syntax, and no type safety.
 */

// ============================================================================
// TYPE DEFINITIONS (Flow Weaver advantage: real TypeScript types!)
// ============================================================================

interface RawLead {
  name: string;
  email: string;
  company: string;
  budget: number;
  source?: string;
}

interface ValidationResult {
  isValid: boolean;
  errors: string[];
  lead: RawLead;
}

interface EnrichedLead extends RawLead {
  timestamp: string;
  normalizedName: string;
  normalizedCompany: string;
  domain: string;
}

interface ScoredLead extends EnrichedLead {
  score: number;
  scoreBreakdown: {
    budgetScore: number;
    companyScore: number;
    sourceScore: number;
  };
}

interface ProcessedLead extends ScoredLead {
  category: 'high' | 'medium' | 'low';
  priority: number;
  followUpDate: string;
}

// ============================================================================
// NODE TYPES
// ============================================================================

/**
 * Validates incoming lead data
- Checks required fields
- Validates email format with regex
- Returns validation errors if any
 *
 * @flowWeaver nodeType
 * @label Validate Lead
 * @input lead [order:1] - Raw lead data to validate
 * @input execute [order:0] - Execute
 * @output validationResult [order:2] - Validation result with errors
 * @output isValid [order:3] - Whether the lead passed validation
 * @output onSuccess [order:0] - On Success
 * @output onFailure [order:1] - On Failure
 */
function validateLead(
  execute: boolean,
  lead: RawLead
): {
  onSuccess: boolean;
  onFailure: boolean;
  validationResult: ValidationResult;
  isValid: boolean;
} {
  if (!execute) {
    return {
      onSuccess: false,
      onFailure: false,
      validationResult: { isValid: false, errors: [], lead: {} as RawLead },
      isValid: false
    };
  }

  const errors: string[] = [];

  // Required field validation
  if (!lead.name || lead.name.trim() === '') {
    errors.push('Name is required');
  }

  if (!lead.email || lead.email.trim() === '') {
    errors.push('Email is required');
  } else {
    // Email format validation with regex (would be painful in n8n expressions!)
    const emailRegex = /^[^\s@]+@[^\s@]+\.[^\s@]+$/;
    if (!emailRegex.test(lead.email)) {
      errors.push('Invalid email format');
    }
  }

  if (!lead.company || lead.company.trim() === '') {
    errors.push('Company is required');
  }

  if (typeof lead.budget !== 'number' || lead.budget < 0) {
    errors.push('Budget must be a positive number');
  }

  const isValid = errors.length === 0;

  return {
    onSuccess: isValid,
    onFailure: !isValid,
    validationResult: { isValid, errors, lead },
    isValid
  };
}

/**
 * Enriches lead data with additional fields
- Adds timestamp
- Normalizes strings
- Extracts email domain
 *
 * @flowWeaver nodeType
 * @label Enrich Lead
 * @input lead [order:1] - Validated lead to enrich
 * @input execute [order:0] - Execute
 * @output enrichedLead [order:2] - Lead with additional data
 * @output onSuccess [order:0] - On Success
 * @output onFailure [order:1] - On Failure
 */
function enrichLead(
  execute: boolean,
  lead: RawLead
): {
  onSuccess: boolean;
  onFailure: boolean;
  enrichedLead: EnrichedLead;
} {
  if (!execute) {
    return {
      onSuccess: false,
      onFailure: false,
      enrichedLead: {} as EnrichedLead
    };
  }

  // Extract domain from email
  const domain = lead.email.split('@')[1] || '';

  // Normalize strings (title case for name, uppercase for company)
  const normalizedName = lead.name
    .trim()
    .split(' ')
    .map(word => word.charAt(0).toUpperCase() + word.slice(1).toLowerCase())
    .join(' ');

  const normalizedCompany = lead.company.trim().toUpperCase();

  const enrichedLead: EnrichedLead = {
    ...lead,
    timestamp: new Date().toISOString(),
    normalizedName,
    normalizedCompany,
    domain
  };

  return {
    onSuccess: true,
    onFailure: false,
    enrichedLead
  };
}

/**
 * Calculates lead score based on multiple factors
- Budget score (0-40 points)
- Company indicators (0-40 points)
- Source quality (0-20 points)
 *
 * @flowWeaver nodeType
 * @label Score Lead
 * @input lead [order:1] - Enriched lead to score
 * @input execute [order:0] - Execute
 * @output scoredLead [order:2] - Lead with score and breakdown
 * @output onSuccess [order:0] - On Success
 * @output onFailure [order:1] - On Failure
 */
function scoreLead(
  execute: boolean,
  lead: EnrichedLead
): {
  onSuccess: boolean;
  onFailure: boolean;
  scoredLead: ScoredLead;
} {
  if (!execute) {
    return {
      onSuccess: false,
      onFailure: false,
      scoredLead: {} as ScoredLead
    };
  }

  // Budget scoring (0-40 points)
  let budgetScore = 0;
  if (lead.budget >= 100000) budgetScore = 40;
  else if (lead.budget >= 50000) budgetScore = 30;
  else if (lead.budget >= 25000) budgetScore = 20;
  else if (lead.budget >= 10000) budgetScore = 10;
  else budgetScore = 5;

  // Company scoring based on domain indicators (0-40 points)
  let companyScore = 0;
  const enterpriseDomains = ['.enterprise', '.corp', '.inc'];
  const premiumIndicators = ['enterprise', 'global', 'international', 'group'];

  // Check for enterprise-ish domain
  if (enterpriseDomains.some(d => lead.domain.includes(d))) {
    companyScore += 20;
  }

  // Check for premium company name indicators
  if (premiumIndicators.some(ind => lead.normalizedCompany.toLowerCase().includes(ind))) {
    companyScore += 20;
  } else if (lead.normalizedCompany.length > 10) {
    companyScore += 10; // Longer names often indicate established companies
  }

  // Source scoring (0-20 points)
  let sourceScore = 0;
  const sourceScores: Record<string, number> = {
    'referral': 20,
    'enterprise-contact': 20,
    'demo-request': 15,
    'webinar': 10,
    'website': 5,
    'cold-outreach': 2
  };
  sourceScore = sourceScores[lead.source || ''] || 5;

  const score = budgetScore + companyScore + sourceScore;

  const scoredLead: ScoredLead = {
    ...lead,
    score,
    scoreBreakdown: {
      budgetScore,
      companyScore,
      sourceScore
    }
  };

  return {
    onSuccess: true,
    onFailure: false,
    scoredLead
  };
}

/**
 * Categorizes lead and sets priority based on score
- High: score >= 70 (priority 1, follow up in 1 day)
- Medium: score >= 40 (priority 2, follow up in 3 days)
- Low: score < 40 (priority 3, follow up in 7 days)
 *
 * @flowWeaver nodeType
 * @label Categorize Lead
 * @input lead [order:1] - Scored lead to categorize
 * @input execute [order:0] - Execute
 * @output processedLead [order:2] - Final processed lead with category
 * @output onSuccess [order:0] - On Success
 * @output onFailure [order:1] - On Failure
 */
function categorizeLead(
  execute: boolean,
  lead: ScoredLead
): {
  onSuccess: boolean;
  onFailure: boolean;
  processedLead: ProcessedLead;
} {
  if (!execute) {
    return {
      onSuccess: false,
      onFailure: false,
      processedLead: {} as ProcessedLead
    };
  }

  let category: 'high' | 'medium' | 'low';
  let priority: number;
  let followUpDays: number;

  if (lead.score >= 70) {
    category = 'high';
    priority = 1;
    followUpDays = 1;
  } else if (lead.score >= 40) {
    category = 'medium';
    priority = 2;
    followUpDays = 3;
  } else {
    category = 'low';
    priority = 3;
    followUpDays = 7;
  }

  // Calculate follow-up date
  const followUpDate = new Date();
  followUpDate.setDate(followUpDate.getDate() + followUpDays);

  const processedLead: ProcessedLead = {
    ...lead,
    category,
    priority,
    followUpDate: followUpDate.toISOString().split('T')[0]
  };

  return {
    onSuccess: true,
    onFailure: false,
    processedLead
  };
}

/**
 * Formats error response when validation fails
 *
 * @flowWeaver nodeType
 * @label Format Error
 * @input validationResult [order:1] - The validation result with errors
 * @input execute [order:0] - Execute
 * @output errorResponse [order:2] - Formatted error response
 * @output onSuccess [order:0] - On Success
 * @output onFailure [order:1] - On Failure
 */
function formatError(
  execute: boolean,
  validationResult: ValidationResult
): {
  onSuccess: boolean;
  onFailure: boolean;
  errorResponse: { success: false; errors: string[]; lead: RawLead };
} {
  if (!execute) {
    return {
      onSuccess: false,
      onFailure: false,
      errorResponse: { success: false, errors: [], lead: {} as RawLead }
    };
  }

  return {
    onSuccess: true,
    onFailure: false,
    errorResponse: {
      success: false,
      errors: validationResult.errors,
      lead: validationResult.lead
    }
  };
}

// ============================================================================
// WORKFLOW DEFINITION
// ============================================================================

/**
 * @flowWeaver workflow
 * @node validator validateLead
 * @node enricher enrichLead
 * @node scorer scoreLead
 * @node categorizer categorizeLead
 * @node errorFormatter formatError
 * @position Start -168 -24
 * @position validator 40 80
 * @position enricher 208 -48
 * @position scorer 400 -50
 * @position categorizer 600 -50
 * @position errorFormatter 408 136
 * @position Exit 864 64
 * @connect Start.lead -> validator.lead
 * @connect validator.onSuccess -> enricher.execute
 * @connect Start.lead -> enricher.lead
 * @connect enricher.enrichedLead -> scorer.lead
 * @connect enricher.onSuccess -> scorer.execute
 * @connect scorer.scoredLead -> categorizer.lead
 * @connect scorer.onSuccess -> categorizer.execute
 * @connect categorizer.processedLead -> Exit.processedLead
 * @connect categorizer.onSuccess -> Exit.onSuccess
 * @connect validator.onFailure -> errorFormatter.execute
 * @connect validator.validationResult -> errorFormatter.validationResult
 * @connect errorFormatter.errorResponse -> Exit.errorResponse
 * @param execute [order:0] - Execute
 * @param lead [order:1] - Lead
 * @returns onSuccess [order:0] - On Success
 * @returns onFailure [order:1] - On Failure
 * @returns processedLead [order:2] - ProcessedLead
 * @returns errorResponse [order:3] - ErrorResponse
 */
export async function processLead(
  execute: boolean,
  params: { lead: RawLead }, __abortSignal__?: AbortSignal
): Promise<{
  onSuccess: boolean;
  onFailure: boolean;
  processedLead?: ProcessedLead;
  errorResponse?: { success: false; errors: string[]; lead: RawLead };
}> {
  // @flow-weaver-body-start
  // ============================================================================
  // DO NOT EDIT - This section is auto-generated by Flow Weaver
  // Edit the @flowWeaver annotations above to modify workflow behavior
  // ============================================================================

    // Use passed debugger or auto-detect from environment variable
    const __effectiveDebugger__ = (
      typeof __flowWeaverDebugger__ !== 'undefined' ? __flowWeaverDebugger__ :
      typeof process !== 'undefined' && process.env.FLOW_WEAVER_DEBUG
        ? createFlowWeaverDebugClient(process.env.FLOW_WEAVER_DEBUG, 'processLead')
        : undefined
    );

    // Recursion depth protection
    const __rd__ = (params as { __rd__?: number }).__rd__ ?? 0;
    if (__rd__ >= 1000) {
      throw new Error('Max recursion depth exceeded (1000) in workflow "processLead"');
    }

    const ctx = new GeneratedExecutionContext(true, __effectiveDebugger__, __abortSignal__);

    const startIdx = ctx.addExecution('Start');
    await ctx.setVariable({ id: 'Start', portName: 'execute', executionIndex: startIdx, nodeTypeName: 'Start' }, execute);
    await ctx.setVariable({ id: 'Start', portName: 'lead', executionIndex: startIdx, nodeTypeName: 'Start' }, params.lead);
    ctx.sendStatusChangedEvent({
      nodeTypeName: 'Start',
      id: 'Start',
      executionIndex: startIdx,
      status: 'SUCCEEDED',
    });

    let enricherIdx: number | undefined;
    let scorerIdx: number | undefined;
    let categorizerIdx: number | undefined;
    let errorFormatterIdx: number | undefined;

    ctx.checkAborted('validator');
    const validatorIdx = ctx.addExecution('validator');
    ctx.sendStatusChangedEvent({
      nodeTypeName: 'validateLead',
      id: 'validator',
      executionIndex: validatorIdx,
      status: 'RUNNING',
    });
  
    let validator_success = false;
  
    try {
      await ctx.setVariable({ id: 'validator', portName: 'execute', executionIndex: validatorIdx, nodeTypeName: 'validateLead' }, true);
      const validator_lead = await ctx.getVariable({ id: 'Start', portName: 'lead', executionIndex: startIdx });
      await ctx.setVariable({ id: 'validator', portName: 'lead', executionIndex: validatorIdx, nodeTypeName: 'validateLead' }, validator_lead);
      const validatorResult = validateLead(true, validator_lead);
      await ctx.setVariable({ id: 'validator', portName: 'validationResult', executionIndex: validatorIdx, nodeTypeName: 'validateLead' }, validatorResult.validationResult);
      await ctx.setVariable({ id: 'validator', portName: 'isValid', executionIndex: validatorIdx, nodeTypeName: 'validateLead' }, validatorResult.isValid);
      await ctx.setVariable({ id: 'validator', portName: 'onSuccess', executionIndex: validatorIdx, nodeTypeName: 'validateLead' }, validatorResult.onSuccess);
      await ctx.setVariable({ id: 'validator', portName: 'onFailure', executionIndex: validatorIdx, nodeTypeName: 'validateLead' }, validatorResult.onFailure);
      ctx.sendStatusChangedEvent({
        nodeTypeName: 'validateLead',
        id: 'validator',
        executionIndex: validatorIdx,
        status: 'SUCCEEDED',
      });
      validator_success = validatorResult.onSuccess;
    } catch (error: unknown) {
      const isCancellation = CancellationError.isCancellationError(error);
      ctx.sendStatusChangedEvent({
        nodeTypeName: 'validateLead',
        id: 'validator',
        executionIndex: validatorIdx,
        status: isCancellation ? 'CANCELLED' : 'FAILED',
      });
      if (!isCancellation) {
        ctx.sendLogErrorEvent({
          nodeTypeName: 'validateLead',
          id: 'validator',
          executionIndex: validatorIdx,
          error: error instanceof Error ? error.message : String(error),
        });
        await ctx.setVariable({ id: 'validator', portName: 'onSuccess', executionIndex: validatorIdx, nodeTypeName: 'validateLead' }, false);
        await ctx.setVariable({ id: 'validator', portName: 'onFailure', executionIndex: validatorIdx, nodeTypeName: 'validateLead' }, true);
        validator_success = false;
      }
      throw error;
    }
  
    if (validator_success) {
      ctx.checkAborted('enricher');
      enricherIdx = ctx.addExecution('enricher');
      ctx.sendStatusChangedEvent({
        nodeTypeName: 'enrichLead',
        id: 'enricher',
        executionIndex: enricherIdx,
        status: 'RUNNING',
      });
    
      let enricher_success = false;
    
      try {
        const enricher_execute = await ctx.getVariable({ id: 'validator', portName: 'onSuccess', executionIndex: validatorIdx! });
        await ctx.setVariable({ id: 'enricher', portName: 'execute', executionIndex: enricherIdx, nodeTypeName: 'enrichLead' }, enricher_execute);
        const enricher_lead = await ctx.getVariable({ id: 'Start', portName: 'lead', executionIndex: startIdx });
        await ctx.setVariable({ id: 'enricher', portName: 'lead', executionIndex: enricherIdx, nodeTypeName: 'enrichLead' }, enricher_lead);
        const enricherResult = enrichLead(enricher_execute, enricher_lead);
        await ctx.setVariable({ id: 'enricher', portName: 'enrichedLead', executionIndex: enricherIdx, nodeTypeName: 'enrichLead' }, enricherResult.enrichedLead);
        await ctx.setVariable({ id: 'enricher', portName: 'onSuccess', executionIndex: enricherIdx, nodeTypeName: 'enrichLead' }, enricherResult.onSuccess);
        await ctx.setVariable({ id: 'enricher', portName: 'onFailure', executionIndex: enricherIdx, nodeTypeName: 'enrichLead' }, enricherResult.onFailure);
        ctx.sendStatusChangedEvent({
          nodeTypeName: 'enrichLead',
          id: 'enricher',
          executionIndex: enricherIdx,
          status: 'SUCCEEDED',
        });
        enricher_success = enricherResult.onSuccess;
      } catch (error: unknown) {
        const isCancellation = CancellationError.isCancellationError(error);
        ctx.sendStatusChangedEvent({
          nodeTypeName: 'enrichLead',
          id: 'enricher',
          executionIndex: enricherIdx,
          status: isCancellation ? 'CANCELLED' : 'FAILED',
        });
        if (!isCancellation) {
          ctx.sendLogErrorEvent({
            nodeTypeName: 'enrichLead',
            id: 'enricher',
            executionIndex: enricherIdx,
            error: error instanceof Error ? error.message : String(error),
          });
          await ctx.setVariable({ id: 'enricher', portName: 'onSuccess', executionIndex: enricherIdx, nodeTypeName: 'enrichLead' }, false);
          await ctx.setVariable({ id: 'enricher', portName: 'onFailure', executionIndex: enricherIdx, nodeTypeName: 'enrichLead' }, true);
          enricher_success = false;
        }
        throw error;
      }
    
      if (enricher_success) {
        ctx.checkAborted('scorer');
        scorerIdx = ctx.addExecution('scorer');
        ctx.sendStatusChangedEvent({
          nodeTypeName: 'scoreLead',
          id: 'scorer',
          executionIndex: scorerIdx,
          status: 'RUNNING',
        });
      
        let scorer_success = false;
      
        try {
          const scorer_execute = await ctx.getVariable({ id: 'enricher', portName: 'onSuccess', executionIndex: enricherIdx! });
          await ctx.setVariable({ id: 'scorer', portName: 'execute', executionIndex: scorerIdx, nodeTypeName: 'scoreLead' }, scorer_execute);
          const scorer_lead = await ctx.getVariable({ id: 'enricher', portName: 'enrichedLead', executionIndex: enricherIdx! });
          await ctx.setVariable({ id: 'scorer', portName: 'lead', executionIndex: scorerIdx, nodeTypeName: 'scoreLead' }, scorer_lead);
          const scorerResult = scoreLead(scorer_execute, scorer_lead);
          await ctx.setVariable({ id: 'scorer', portName: 'scoredLead', executionIndex: scorerIdx, nodeTypeName: 'scoreLead' }, scorerResult.scoredLead);
          await ctx.setVariable({ id: 'scorer', portName: 'onSuccess', executionIndex: scorerIdx, nodeTypeName: 'scoreLead' }, scorerResult.onSuccess);
          await ctx.setVariable({ id: 'scorer', portName: 'onFailure', executionIndex: scorerIdx, nodeTypeName: 'scoreLead' }, scorerResult.onFailure);
          ctx.sendStatusChangedEvent({
            nodeTypeName: 'scoreLead',
            id: 'scorer',
            executionIndex: scorerIdx,
            status: 'SUCCEEDED',
          });
          scorer_success = scorerResult.onSuccess;
        } catch (error: unknown) {
          const isCancellation = CancellationError.isCancellationError(error);
          ctx.sendStatusChangedEvent({
            nodeTypeName: 'scoreLead',
            id: 'scorer',
            executionIndex: scorerIdx,
            status: isCancellation ? 'CANCELLED' : 'FAILED',
          });
          if (!isCancellation) {
            ctx.sendLogErrorEvent({
              nodeTypeName: 'scoreLead',
              id: 'scorer',
              executionIndex: scorerIdx,
              error: error instanceof Error ? error.message : String(error),
            });
            await ctx.setVariable({ id: 'scorer', portName: 'onSuccess', executionIndex: scorerIdx, nodeTypeName: 'scoreLead' }, false);
            await ctx.setVariable({ id: 'scorer', portName: 'onFailure', executionIndex: scorerIdx, nodeTypeName: 'scoreLead' }, true);
            scorer_success = false;
          }
          throw error;
        }
      
        if (scorer_success) {
          ctx.checkAborted('categorizer');
          categorizerIdx = ctx.addExecution('categorizer');
          ctx.sendStatusChangedEvent({
            nodeTypeName: 'categorizeLead',
            id: 'categorizer',
            executionIndex: categorizerIdx,
            status: 'RUNNING',
          });
        
          try {
            const categorizer_execute = await ctx.getVariable({ id: 'scorer', portName: 'onSuccess', executionIndex: scorerIdx! });
            await ctx.setVariable({ id: 'categorizer', portName: 'execute', executionIndex: categorizerIdx, nodeTypeName: 'categorizeLead' }, categorizer_execute);
            const categorizer_lead = await ctx.getVariable({ id: 'scorer', portName: 'scoredLead', executionIndex: scorerIdx! });
            await ctx.setVariable({ id: 'categorizer', portName: 'lead', executionIndex: categorizerIdx, nodeTypeName: 'categorizeLead' }, categorizer_lead);
            const categorizerResult = categorizeLead(categorizer_execute, categorizer_lead);
            await ctx.setVariable({ id: 'categorizer', portName: 'processedLead', executionIndex: categorizerIdx, nodeTypeName: 'categorizeLead' }, categorizerResult.processedLead);
            await ctx.setVariable({ id: 'categorizer', portName: 'onSuccess', executionIndex: categorizerIdx, nodeTypeName: 'categorizeLead' }, categorizerResult.onSuccess);
            await ctx.setVariable({ id: 'categorizer', portName: 'onFailure', executionIndex: categorizerIdx, nodeTypeName: 'categorizeLead' }, categorizerResult.onFailure);
            ctx.sendStatusChangedEvent({
              nodeTypeName: 'categorizeLead',
              id: 'categorizer',
              executionIndex: categorizerIdx,
              status: 'SUCCEEDED',
            });
          } catch (error: unknown) {
            const isCancellation = CancellationError.isCancellationError(error);
            ctx.sendStatusChangedEvent({
              nodeTypeName: 'categorizeLead',
              id: 'categorizer',
              executionIndex: categorizerIdx,
              status: isCancellation ? 'CANCELLED' : 'FAILED',
            });
            if (!isCancellation) {
              ctx.sendLogErrorEvent({
                nodeTypeName: 'categorizeLead',
                id: 'categorizer',
                executionIndex: categorizerIdx,
                error: error instanceof Error ? error.message : String(error),
              });
              await ctx.setVariable({ id: 'categorizer', portName: 'onSuccess', executionIndex: categorizerIdx, nodeTypeName: 'categorizeLead' }, false);
              await ctx.setVariable({ id: 'categorizer', portName: 'onFailure', executionIndex: categorizerIdx, nodeTypeName: 'categorizeLead' }, true);
            }
            throw error;
          }
        
        }
      }
    } else {
      ctx.checkAborted('errorFormatter');
      errorFormatterIdx = ctx.addExecution('errorFormatter');
      ctx.sendStatusChangedEvent({
        nodeTypeName: 'formatError',
        id: 'errorFormatter',
        executionIndex: errorFormatterIdx,
        status: 'RUNNING',
      });
      try {
        const errorFormatter_execute = await ctx.getVariable({ id: 'validator', portName: 'onFailure', executionIndex: validatorIdx! });
        await ctx.setVariable({ id: 'errorFormatter', portName: 'execute', executionIndex: errorFormatterIdx, nodeTypeName: 'formatError' }, errorFormatter_execute);
        const errorFormatter_validationResult = await ctx.getVariable({ id: 'validator', portName: 'validationResult', executionIndex: validatorIdx! });
        await ctx.setVariable({ id: 'errorFormatter', portName: 'validationResult', executionIndex: errorFormatterIdx, nodeTypeName: 'formatError' }, errorFormatter_validationResult);
        const errorFormatterResult = formatError(errorFormatter_execute, errorFormatter_validationResult);
        await ctx.setVariable({ id: 'errorFormatter', portName: 'errorResponse', executionIndex: errorFormatterIdx, nodeTypeName: 'formatError' }, errorFormatterResult.errorResponse);
        await ctx.setVariable({ id: 'errorFormatter', portName: 'onSuccess', executionIndex: errorFormatterIdx, nodeTypeName: 'formatError' }, errorFormatterResult.onSuccess);
        await ctx.setVariable({ id: 'errorFormatter', portName: 'onFailure', executionIndex: errorFormatterIdx, nodeTypeName: 'formatError' }, errorFormatterResult.onFailure);
        ctx.sendStatusChangedEvent({
          nodeTypeName: 'formatError',
          id: 'errorFormatter',
          executionIndex: errorFormatterIdx,
          status: 'SUCCEEDED',
        });
      } catch (error: unknown) {
        const isCancellation = CancellationError.isCancellationError(error);
        ctx.sendStatusChangedEvent({
          nodeTypeName: 'formatError',
          id: 'errorFormatter',
          executionIndex: errorFormatterIdx,
          status: isCancellation ? 'CANCELLED' : 'FAILED',
        });
        if (!isCancellation) {
          ctx.sendLogErrorEvent({
            nodeTypeName: 'formatError',
            id: 'errorFormatter',
            executionIndex: errorFormatterIdx,
            error: error instanceof Error ? error.message : String(error),
          });
        }
        throw error;
      }
    }
    const exitIdx = ctx.addExecution('Exit');
    const exit_processedLead = categorizerIdx !== undefined ? await ctx.getVariable({ id: 'categorizer', portName: 'processedLead', executionIndex: categorizerIdx }) : undefined;
    await ctx.setVariable({ id: 'Exit', portName: 'processedLead', executionIndex: exitIdx, nodeTypeName: 'Exit' }, exit_processedLead);
    const exit_onSuccess = categorizerIdx !== undefined ? await ctx.getVariable({ id: 'categorizer', portName: 'onSuccess', executionIndex: categorizerIdx }) : undefined;
    await ctx.setVariable({ id: 'Exit', portName: 'onSuccess', executionIndex: exitIdx, nodeTypeName: 'Exit' }, exit_onSuccess);
    const exit_errorResponse = errorFormatterIdx !== undefined ? await ctx.getVariable({ id: 'errorFormatter', portName: 'errorResponse', executionIndex: errorFormatterIdx }) : undefined;
    await ctx.setVariable({ id: 'Exit', portName: 'errorResponse', executionIndex: exitIdx, nodeTypeName: 'Exit' }, exit_errorResponse);

    await ctx.setVariable({ id: 'Exit', portName: 'onFailure', executionIndex: exitIdx, nodeTypeName: 'Exit' }, false);
    const finalResult = { onFailure: false, processedLead: exit_processedLead as unknown, onSuccess: exit_onSuccess as boolean, errorResponse: exit_errorResponse as unknown };

    ctx.sendStatusChangedEvent({
      nodeTypeName: 'Exit',
      id: 'Exit',
      executionIndex: exitIdx,
      status: 'SUCCEEDED',
    });
    ctx.sendWorkflowCompletedEvent({
      executionIndex: 0,
      status: 'SUCCEEDED',
      result: finalResult,
    });

    return finalResult;
  // @flow-weaver-body-end
}

// ============================================================================
// ADDITIONAL EXPORTS (demonstrating multiple workflows in one file)
// ============================================================================

/**
 * @flowWeaver nodeType
 * @input execute [order:0] - Execute
 * @input lead [order:1] - Lead
 * @output onSuccess [order:0] - On Success
 * @output onFailure [order:1] - On Failure
 * @output result [order:2] - Result
 * @output isValid [order:3] - IsValid
 */
export async function validateOnly(
  _execute: boolean,
  _params: { lead: RawLead }
): Promise<{
  onSuccess: boolean;
  onFailure: boolean;
  result: ValidationResult;
  isValid: boolean;
}> {
  throw new Error('Not implemented - Flow Weaver will generate this');
}

/**
 * @flowWeaver nodeType
 * @input execute [order:0] - Execute
 * @input lead [order:1] - Lead
 * @output onSuccess [order:0] - On Success
 * @output onFailure [order:1] - On Failure
 * @output result [order:2] - Result
 */
export async function scoreAndCategorize(
  _execute: boolean,
  _params: { lead: EnrichedLead }
): Promise<{
  onSuccess: boolean;
  onFailure: boolean;
  result: ProcessedLead;
}> {
  throw new Error('Not implemented - Flow Weaver will generate this');
}
