/* eslint-disable @typescript-eslint/no-require-imports */
// @flow-weaver-runtime-start
// ============================================================================
// DO NOT EDIT - This section is auto-generated by Flow Weaver
// ============================================================================

import { GeneratedExecutionContext, CancellationError } from '@synergenius/flow-weaver/runtime';
import type { TDebugger } from '@synergenius/flow-weaver/runtime';
// @flow-weaver-runtime-end
// Example workflow with ForEach scoped execution

// ============================================================================
// NODE DEFINITIONS
// ============================================================================

/**
 * ForEach container node - iterates over items
 *
 * @flowWeaver nodeType
 * @label ForEach
 * @input items [order:1] - Items
 * @input execute [order:0] - Execute
 * @input success scope:iteration [order:0] - Success from iteration
 * @input failure scope:iteration [order:1] - Failure from iteration
 * @input result scope:iteration [order:2] - Result from iteration
 * @output start scope:iteration [order:0] - Start control for iteration
 * @output item scope:iteration [order:1] - Current item
 * @output results [order:2] - Results
 * @output onSuccess [order:0] - On Success
 * @output onFailure [order:1] - On Failure
 */
async function forEach(
  execute: boolean,
  items: any[],
  iteration: (start: boolean, item: any) => Promise<{
    success: boolean;
    failure: boolean;
    result: any;
  }>
) {
  if (!execute) return { results: [], onSuccess: false, onFailure: false };
  const results: any[] = [];
  for (const item of items) {
    const r = await iteration(true, item);
    results.push(r.result);
  }
  return { results, onSuccess: true, onFailure: false };
}

/**
 * Process Item - executes within forEach scope
 *
 * @flowWeaver nodeType
 * @label Process Item
 * @input item [order:1] - Item
 * @input execute [order:0] - Execute
 * @output processed [order:2] - Processed
 * @output onSuccess [order:0] - On Success
 * @output onFailure [order:1] - On Failure
 */
function processItem(execute: boolean, item: any) {
  if (!execute) return { onSuccess: false, onFailure: false, processed: null };
  return { onSuccess: true, onFailure: false, processed: item };
}

/**
 * Double Value - executes within forEach scope
 *
 * @flowWeaver nodeType
 * @label Double
 * @input value [order:1] - Value
 * @input execute [order:0] - Execute
 * @output doubled [order:2] - Doubled
 * @output onSuccess [order:0] - On Success
 * @output onFailure [order:1] - On Failure
 */
function double(execute: boolean, value: number) {
  return { onSuccess: true, onFailure: false, doubled: value * 2 };
}

// ============================================================================
// WORKFLOW DEFINITION
// ============================================================================

/**
 * @flowWeaver workflow
 * @node forEach forEach
 * @node processItem processItem forEach.iteration
 * @node double double forEach.iteration
 * @path Start -> forEach -> Exit
 * @path Start -> forEach:fail -> Exit
 * @position Start 0 0
 * @position forEach 270 0
 * @position processItem 540 0
 * @position double 810 0
 * @position Exit 1080 0
 * @connect forEach.start:iteration -> processItem.execute
 * @connect forEach.item:iteration -> processItem.item
 * @connect processItem.onSuccess -> double.execute
 * @connect processItem.processed -> double.value
 * @connect double.doubled -> forEach.result:iteration
 * @connect double.onSuccess -> forEach.success:iteration
 * @connect double.onFailure -> forEach.failure:iteration
 * @connect forEach.results -> Exit.results
 * @param execute [order:0] - Execute
 * @param items [order:1] - Items
 * @returns onSuccess [order:0] - On Success
 * @returns onFailure [order:1] - On Failure
 * @returns results [order:2] - Results
 */
export async function processArray(
  execute: boolean,
  params: { items: any[] }, __abortSignal__?: AbortSignal
): Promise<{ onSuccess: boolean; onFailure: boolean; results: any[] }> {
  // @flow-weaver-body-start
  // ============================================================================
  // DO NOT EDIT - This section is auto-generated by Flow Weaver
  // Edit the @flowWeaver annotations above to modify workflow behavior
  // ============================================================================

    // Use passed debugger or auto-detect from environment variable
    const __effectiveDebugger__ = (
      typeof __flowWeaverDebugger__ !== 'undefined' ? __flowWeaverDebugger__ :
      typeof process !== 'undefined' && process.env.FLOW_WEAVER_DEBUG
        ? createFlowWeaverDebugClient(process.env.FLOW_WEAVER_DEBUG, 'processArray')
        : undefined
    );

    // Recursion depth protection
    const __rd__ = (params as { __rd__?: number }).__rd__ ?? 0;
    if (__rd__ >= 1000) {
      throw new Error('Max recursion depth exceeded (1000) in workflow "processArray"');
    }

    const ctx = new GeneratedExecutionContext(true, __effectiveDebugger__, __abortSignal__);

    const startIdx = ctx.addExecution('Start');
    await ctx.setVariable({ id: 'Start', portName: 'execute', executionIndex: startIdx, nodeTypeName: 'Start' }, execute);
    await ctx.setVariable({ id: 'Start', portName: 'items', executionIndex: startIdx, nodeTypeName: 'Start' }, params.items);
    ctx.sendStatusChangedEvent({
      nodeTypeName: 'Start',
      id: 'Start',
      executionIndex: startIdx,
      status: 'SUCCEEDED',
    });

    let forEachIdx: number | undefined;

    ctx.checkAborted('forEach');
    forEachIdx = ctx.addExecution('forEach');
    ctx.sendStatusChangedEvent({
      nodeTypeName: 'forEach',
      id: 'forEach',
      executionIndex: forEachIdx,
      status: 'RUNNING',
    });

    try {
      const forEach_execute = await ctx.getVariable({ id: 'Start', portName: 'execute', executionIndex: startIdx }) as boolean;
      await ctx.setVariable({ id: 'forEach', portName: 'execute', executionIndex: forEachIdx, nodeTypeName: 'forEach' }, forEach_execute);
      const forEach_items = await ctx.getVariable({ id: 'Start', portName: 'items', executionIndex: startIdx }) as any[];
      await ctx.setVariable({ id: 'forEach', portName: 'items', executionIndex: forEachIdx, nodeTypeName: 'forEach' }, forEach_items);
      const forEach_iteration_scopeFn = ((ctx) => {
        return async (start: boolean, item: any) => {
          // Scope function body for 'iteration'
    
          // Create scoped context for child nodes
          const scopedCtx = ctx.createScope('forEach', forEachIdx!, 'iteration', true);
    
          // Set scope parameters as variables for child nodes
          const scopeParamIdx_start = scopedCtx.addExecution('forEach_param_start');
          await scopedCtx.setVariable({ id: 'forEach', portName: 'start', executionIndex: scopeParamIdx_start, nodeTypeName: 'forEach', scope: 'iteration', side: 'start' }, start);
          const scopeParamIdx_item = scopedCtx.addExecution('forEach_param_item');
          await scopedCtx.setVariable({ id: 'forEach', portName: 'item', executionIndex: scopeParamIdx_item, nodeTypeName: 'forEach', scope: 'iteration', side: 'start' }, item);
    
          // Execute child nodes in topologically sorted order
    
          // Execute: processItem (processItem)
          scopedCtx.checkAborted('processItem');
          const processItemIdx = scopedCtx.addExecution('processItem');
          scopedCtx.sendStatusChangedEvent({
            nodeTypeName: 'processItem',
            id: 'processItem',
            executionIndex: processItemIdx,
            status: 'RUNNING',
          });
          try {
            const processItem_execute = await scopedCtx.getVariable({ id: 'forEach', portName: 'start', executionIndex: scopeParamIdx_start }) as boolean;
            await scopedCtx.setVariable({ id: 'processItem', portName: 'execute', executionIndex: processItemIdx, nodeTypeName: 'processItem' }, processItem_execute);
            const processItem_item = await scopedCtx.getVariable({ id: 'forEach', portName: 'item', executionIndex: scopeParamIdx_item }) as any;
            await scopedCtx.setVariable({ id: 'processItem', portName: 'item', executionIndex: processItemIdx, nodeTypeName: 'processItem' }, processItem_item);
            const processItemResult = await processItem(processItem_execute, processItem_item);
            await scopedCtx.setVariable({ id: 'processItem', portName: 'processed', executionIndex: processItemIdx, nodeTypeName: 'processItem' }, processItemResult.processed);
            await scopedCtx.setVariable({ id: 'processItem', portName: 'onSuccess', executionIndex: processItemIdx, nodeTypeName: 'processItem' }, processItemResult.onSuccess);
            await scopedCtx.setVariable({ id: 'processItem', portName: 'onFailure', executionIndex: processItemIdx, nodeTypeName: 'processItem' }, processItemResult.onFailure);
            scopedCtx.sendStatusChangedEvent({
              nodeTypeName: 'processItem',
              id: 'processItem',
              executionIndex: processItemIdx,
              status: 'SUCCEEDED',
            });
          } catch (error: unknown) {
            const isCancellation = CancellationError.isCancellationError(error);
            scopedCtx.sendStatusChangedEvent({
              nodeTypeName: 'processItem',
              id: 'processItem',
              executionIndex: processItemIdx,
              status: isCancellation ? 'CANCELLED' : 'FAILED',
            });
            if (!isCancellation) {
              scopedCtx.sendLogErrorEvent({
                nodeTypeName: 'processItem',
                id: 'processItem',
                executionIndex: processItemIdx,
                error: error instanceof Error ? error.message : String(error),
              });
            }
            throw error;
          }
    
          // Execute: double (double)
          scopedCtx.checkAborted('double');
          const doubleIdx = scopedCtx.addExecution('double');
          scopedCtx.sendStatusChangedEvent({
            nodeTypeName: 'double',
            id: 'double',
            executionIndex: doubleIdx,
            status: 'RUNNING',
          });
          try {
            const double_execute = await scopedCtx.getVariable({ id: 'processItem', portName: 'onSuccess', executionIndex: processItemIdx! }) as boolean;
            await scopedCtx.setVariable({ id: 'double', portName: 'execute', executionIndex: doubleIdx, nodeTypeName: 'double' }, double_execute);
            const double_value = await scopedCtx.getVariable({ id: 'processItem', portName: 'processed', executionIndex: processItemIdx! }) as number;
            await scopedCtx.setVariable({ id: 'double', portName: 'value', executionIndex: doubleIdx, nodeTypeName: 'double' }, double_value);
            const doubleResult = await double(double_execute, double_value);
            await scopedCtx.setVariable({ id: 'double', portName: 'doubled', executionIndex: doubleIdx, nodeTypeName: 'double' }, doubleResult.doubled);
            await scopedCtx.setVariable({ id: 'double', portName: 'onSuccess', executionIndex: doubleIdx, nodeTypeName: 'double' }, doubleResult.onSuccess);
            await scopedCtx.setVariable({ id: 'double', portName: 'onFailure', executionIndex: doubleIdx, nodeTypeName: 'double' }, doubleResult.onFailure);
            scopedCtx.sendStatusChangedEvent({
              nodeTypeName: 'double',
              id: 'double',
              executionIndex: doubleIdx,
              status: 'SUCCEEDED',
            });
          } catch (error: unknown) {
            const isCancellation = CancellationError.isCancellationError(error);
            scopedCtx.sendStatusChangedEvent({
              nodeTypeName: 'double',
              id: 'double',
              executionIndex: doubleIdx,
              status: isCancellation ? 'CANCELLED' : 'FAILED',
            });
            if (!isCancellation) {
              scopedCtx.sendLogErrorEvent({
                nodeTypeName: 'double',
                id: 'double',
                executionIndex: doubleIdx,
                error: error instanceof Error ? error.message : String(error),
              });
            }
            throw error;
          }
    
          // Merge scoped execution back to parent context
          ctx.mergeScope(scopedCtx);
    
          // Extract return values from child outputs
          const scopeExitIdx = ctx.addExecution('forEach_scope_exit');
          const scopeReturn_success = ctx.hasVariable({ id: 'double', portName: 'onSuccess', executionIndex: doubleIdx, nodeTypeName: 'double' }) ? await ctx.getVariable({ id: 'double', portName: 'onSuccess', executionIndex: doubleIdx, nodeTypeName: 'double' }) as boolean : true;
          await ctx.setVariable({ id: 'forEach', portName: 'success', executionIndex: scopeExitIdx, scope: 'iteration', side: 'exit', nodeTypeName: 'forEach' }, scopeReturn_success);
          const scopeReturn_failure = ctx.hasVariable({ id: 'double', portName: 'onFailure', executionIndex: doubleIdx, nodeTypeName: 'double' }) ? await ctx.getVariable({ id: 'double', portName: 'onFailure', executionIndex: doubleIdx, nodeTypeName: 'double' }) as boolean : false;
          await ctx.setVariable({ id: 'forEach', portName: 'failure', executionIndex: scopeExitIdx, scope: 'iteration', side: 'exit', nodeTypeName: 'forEach' }, scopeReturn_failure);
          const scopeReturn_result = await ctx.getVariable({ id: 'double', portName: 'doubled', executionIndex: doubleIdx, nodeTypeName: 'double' }) as any;
          await ctx.setVariable({ id: 'forEach', portName: 'result', executionIndex: scopeExitIdx, scope: 'iteration', side: 'exit', nodeTypeName: 'forEach' }, scopeReturn_result);
          return { success: scopeReturn_success, failure: scopeReturn_failure, result: scopeReturn_result };
        };
      })(ctx);
      const forEachResult = await forEach(forEach_execute, forEach_items, forEach_iteration_scopeFn);
      await ctx.setVariable({ id: 'forEach', portName: 'results', executionIndex: forEachIdx, nodeTypeName: 'forEach' }, forEachResult.results);
      await ctx.setVariable({ id: 'forEach', portName: 'onSuccess', executionIndex: forEachIdx, nodeTypeName: 'forEach' }, forEachResult.onSuccess);
      await ctx.setVariable({ id: 'forEach', portName: 'onFailure', executionIndex: forEachIdx, nodeTypeName: 'forEach' }, forEachResult.onFailure);
      ctx.sendStatusChangedEvent({
        nodeTypeName: 'forEach',
        id: 'forEach',
        executionIndex: forEachIdx,
        status: 'SUCCEEDED',
      });
    } catch (error: unknown) {
      const isCancellation = CancellationError.isCancellationError(error);
      ctx.sendStatusChangedEvent({
        nodeTypeName: 'forEach',
        id: 'forEach',
        executionIndex: forEachIdx,
        status: isCancellation ? 'CANCELLED' : 'FAILED',
      });
      if (!isCancellation) {
        ctx.sendLogErrorEvent({
          nodeTypeName: 'forEach',
          id: 'forEach',
          executionIndex: forEachIdx,
          error: error instanceof Error ? error.message : String(error),
        });
        await ctx.setVariable({ id: 'forEach', portName: 'onSuccess', executionIndex: forEachIdx, nodeTypeName: 'forEach' }, false);
        await ctx.setVariable({ id: 'forEach', portName: 'onFailure', executionIndex: forEachIdx, nodeTypeName: 'forEach' }, true);
      }
      throw error;
    }

    const exitIdx = ctx.addExecution('Exit');
    const exit_results = forEachIdx !== undefined ? await ctx.getVariable({ id: 'forEach', portName: 'results', executionIndex: forEachIdx }) : undefined;
    await ctx.setVariable({ id: 'Exit', portName: 'results', executionIndex: exitIdx, nodeTypeName: 'Exit' }, exit_results);
    const exit_onSuccess = forEachIdx !== undefined ? await ctx.getVariable({ id: 'forEach', portName: 'onSuccess', executionIndex: forEachIdx }) : false;
    await ctx.setVariable({ id: 'Exit', portName: 'onSuccess', executionIndex: exitIdx, nodeTypeName: 'Exit' }, exit_onSuccess);
    const exit_onFailure = forEachIdx !== undefined ? await ctx.getVariable({ id: 'forEach', portName: 'onFailure', executionIndex: forEachIdx }) : false;
    await ctx.setVariable({ id: 'Exit', portName: 'onFailure', executionIndex: exitIdx, nodeTypeName: 'Exit' }, exit_onFailure);

    const finalResult = { results: exit_results as any[], onSuccess: exit_onSuccess as boolean, onFailure: exit_onFailure as boolean };

    ctx.sendStatusChangedEvent({
      nodeTypeName: 'Exit',
      id: 'Exit',
      executionIndex: exitIdx,
      status: 'SUCCEEDED',
    });
    ctx.sendWorkflowCompletedEvent({
      executionIndex: exitIdx,
      status: 'SUCCEEDED',
      result: finalResult,
    });

    return finalResult;
  // @flow-weaver-body-end
}

export { forEach, processItem, double };
